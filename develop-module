Developing modules                                                        
Modules are the workhorse of Ansible. They provide just enough abstraction so that playbooks can be stated simply and clearly. There are over 100 modules maintained by the core Ansible development team, covering clouds, commands, databases, files, networks, packaging, source control, system, utilities, web infrastructure, and so on. In addition, there are nearly 2,000 other modules maintained by community contributors that expand functionality in many of these categories. The real magic happens inside the module code, which takes in the arguments passed to it and works to establish the desired outcome.Modules in Ansible are the pieces of code that get transported to the remote host to be executed. They can be written in any language that the remote host can execute; however, Ansible provides some very useful shortcuts for writing modules in Python.

The basic module construct                                                        
A module exists to satisfy a need—the need to do a piece of work on a host. Modules usually, but not always, expect input, and will return some sort of output. Modules also strive to be idempotent, allowing the rerunning of the module over and over again without having a negative impact. In Ansible, the input is in the form of command-line arguments to the module, and the output is delivered as JSON to STDOUT.Input is generally provided in the space-separated key=value syntax, and it's up to the module to deconstruct these into usable data. If you're using Python, there are convenience functions to manage this, and if you're using a different language, then it is up to the module code to fully process the input.The output is JSON formatted. Convention dictates that in a successful scenario, the JSON output should have at least one key, changed, which is a Boolean, to indicate whether the module execution resulted in a change. Additional data can be returned as well, which may be useful to define specifically what changed, or provide important information back to the playbook for later use. Additionally, host facts can be returned in the JSON data to automatically create host variables based on the module execution results. We will see more on this later, in the section entitled Providing fact data.

Custom modules                                                        
Ansible provides an easy mechanism to utilize custom modules other than those that come with Ansible. As we learned in Chapter 1, The System Architecture and Design of Ansible, Ansible will search many locations to find a requested module. One such location, and indeed the first location, is the library/ subdirectory of the path where the top-level playbook resides. This is where we will place our custom module so that we can use it in our example playbook.Modules can also be embedded within roles to deliver the added functionality that a role may depend upon. These modules are only available to the role that contains it or any other roles or tasks executed after the role containing the module. To deliver a module with a role, place the module in the library/ subdirectory of the role's root.

Example – Simple module                                                       
To demonstrate the ease of writing Python-based modules, let's create a simple module. The purpose of this module will be to remotely copy a source file to a destination file, a simple task that we can build up from. To start our module, we need to create the module file. For easy access to our new module, we'll create the file in the library/ subdirectory of the working directory we've already been using. We'll call this module remote_copy.py, and to start it off, we'll need to put in a sha-bang line to indicate that this module is to be executed with Python:

#!/usr/bin/python 

# For Python-based modules, the convention is to use /usr/bin/python as the listed executable. When executed on a remote system, the configured Python interpreter for the remote host is used to execute the module, so fret not if your Python doesn't exist in this path. Next, we'll import a Python library we'll use later in the module, called shutil:

import shutil

Now we're ready to create our main function. The main function is essentially the entry point to the module, where the arguments to the module will be defined and where the execution will start. When creating modules in Python, we can take some shortcuts in this main function to bypass a lot of boilerplate code and get straight to the argument definitions.We do this by creating an AnsibleModule object and giving it an argument_spec dictionary for the arguments:

def main():     
          module = AnsibleModule(         
              argument_spec = dict(             
                   source=dict(required=True, type='str'),             
                   dest=dict(required=True, type='str')         
     )     
) 

In our module, we're providing two arguments. The first argument is source, which we'll use to define the source file for the copy. The second argument is dest, the destination for the copy. Both of these arguments are marked as required, which will raise an error when executed if one of the two is not provided. Both arguments are of the type string. The location of the AnsibleModule class has not yet been defined, as that happens later in the file.With a module object at our disposal, we can now create the code that will do the actual work on the remote host. We'll make use of shutil.copy and our provided arguments to accomplish the copy: 

shutil.copy(module.params['source'],                 
            module.params['dest']) 

The shutil.copy function expects a source and a destination, which we've provided by accessing module.params. The module.params dictionary holds all of the parameters for the module. Having completed the copy, we are now ready to return the results to Ansible. This is done via another AnsibleModule method, exit_json. This method expects a set of key=value arguments and will format it appropriately for a JSON return. Since we're always performing a copy, we will always return a change for simplicity's sake:

module.exit_json(changed=True) 

This line will exit the function, and thus the module. This function assumes a successful action and will exit the module with the appropriate return code for success: 0. We're not done with our module's code though; we still have to account for the AnsibleModule location. This is where a bit of magic happens, where we tell Ansible what other code to combine with our module to create a complete work that can be transported:

from ansible.module_utils.basic import * 

That's all it takes! That one line gets us access to all of the basic module_utils, a decent set of helper functions and classes. There is one last thing we should put into our module: a couple of lines of code telling the interpreter to execute the main() function when the module file is executed:

if __name__ == '__main__':    
    main()

Now our module file is complete and we can test it with a playbook. We'll call our playbook simple_module.yaml and store it in the same directory as the library/ directory, where we've just written our module file. We'll run the play on localhost for simplicity's sake and use a couple of filenames in /tmp for the source and destination. We'll also use a task to ensure that we have a source file to begin with:
--- 
- name: test remote_copy module   
hosts: localhost   
gather_facts: false    
tasks:   
- name: ensure foo    
  file:      
  path: /tmp/rcfoo      
  state: touch  
- name: do a remote copy    
  remote_copy:     
  source: /tmp/rcfoo      
  dest: /tmp/rcbar
 
 To run this playbook, we'll reference our mastery-hosts file. If the remote_copy module file is written to the correct location, everything will work just fine, and the screen output will look as follows:Our first task touches the /tmp/rcfoo path to ensure that it exists, and then our second task makes use of remote_copy to copy /tmp/rcfoo to /tmp/rcbar. Both tasks are successful, resulting in a change each time.


No module should be considered complete unless it contains documentation regarding how to operate it. Documentation for a module exists within the module itself, in special variables called DOCUMENTATION, EXAMPLES, and RETURN.The DOCUMENTATION variable contains a specially formatted string describing the module name, the version that was added to Ansible (if it is in Ansible proper), a short description of the module, a longer description, a description of the module arguments, author and license information, additional requirements, and any extra notes useful to users of the module. Let's add a DOCUMENTATION string to our module under the existing import shutil statement:import shutil  DOCUMENTATION = ''' --- module: remote_copy version_added: future short_description: Copy a file on the remote host description:   - The remote_copy module copies a file on the remote host from a given source to a provided destination. options:   source:     description:       - Path to a file on the source file on the remote host     required: True   dest:     description:       - Path to the destination on the remote host for the copy     required: True author:   - Jesse Keating ''' The format of the string is essentially YAML, with some top-level keys containing hash structures within it (the same as the options key). Each option has sub-elements to describe the option, indicate whether the option is required, list any aliases for the option, list static choices for the option, or indicate a default value for the option. With this string saved to the module, we can test our formatting to ensure that the documentation will render correctly. This is done via the ansible-doc tool, with an argument to indicate where to search for the modules. If we run it from the same place as our playbook, the command will be ansible-doc -M library/ remote_copy, and the output will be as follows:In this example, I've piped the output into cat to prevent the pager from hiding the execution line. Our documentation string appears to be formatted correctly and provides the user with important information regarding the usage of the module.The EXAMPLES string is used to provide one or more example uses of the module, snippets of the task code that you would use in a playbook. Let's add an example task to demonstrate the usage. This variable definition traditionally goes after the DOCUMENTATION definition:EXAMPLES = ''' # Example from Ansible Playbooks - name: backup a config file   remote_copy:     source: /etc/herp/derp.conf     dest: /root/herp-derp.conf.bak ''' With this variable defined, our ansible-doc output will now include the example, as we can see in the following screenshot:The last documentation variable, RETURN, is a relatively new feature of module documentation. This variable is used to describe the return data from a module execution. Return data is often useful as a registered variable for later usage, and having documentation of what return data to expect can aid playbook development. Our module doesn't have any return data yet; so, before we can document any some, we first have to add return data. This can be done by modifying the module.exit_json line to add more information. Let's add the source and dest data to the return output:    module.exit_json(changed=True, source=module.params['source'],                      dest=module.params['dest']) Rerunning the playbook will show extra data being returned, as shown in the following screenshot:Looking closely at the return data, we can see more data than we put in our module. This is actually a bit of a helper functionality within Ansible; when a return dataset includes a dest variable, Ansible will gather more information about the destination file. The extra data gathered is gid (group ID), group (group name), mode (permissions), uid (owner ID), owner (owner name), size, and state (file, link, or directory). We can document all of these return items in our RETURN variable, which is added after the EXAMPLES variable. Everything between the two sets of single quotes (''') is returned – thus, this first part returns the file paths and ownership:RETURN = ''' source:   description: source file used for the copy   returned: success   type: string   sample: "/path/to/file.name" dest:   description: destination of the copy   returned: success   type: string   sample: "/path/to/destination.file" gid:   description: group ID of destination target   returned: success   type: int   sample: 502 group:   description: group name of destination target   returned: success   type: string   sample: "users" uid:   description: owner ID of destination target   returned: success   type: int   sample: 502 owner:   description: owner name of destination target   returned: success   type: string   sample: "fred"Continuing this part of the module definition file, this section returns the details about the file size, state, and permissions:mode:   description: permissions of the destination target   returned: success   type: int   sample: 0644 size:   description: size of destination target   returned: success   type: int   sample: 20 state:   description: state of destination target   returned: success   type: string   sample: "file" ''' Each returned item is listed with a description, the cases when the item would be in the return data, the type of item it is, and a sample of the value. The RETURN string is essentially repeated verbatim in the ansible-doc output, as shown in the following (abbreviated) example:In this way, we have built up a module that contains its own documentation – incredibly useful for others if we are contributing it to the community, or even for ourselves when we come back to it after a period of time.                                      			Highlight															?									Delete Note					Save Note					Cancel										      Highlight      Close                           Are you sure you want to permanently delete this note?                              No, I changed my mind            Yes, delete it                   					Copy				Add Highlight					Add Note					

Providing fact data                                                        Similar to data returned as part of a module exit, a module can directly create facts for a host by returning data in a key named ansible_facts. Providing facts directly from a module eliminates the need to register the return of a task with a subsequent set_fact task. To demonstrate this usage, let's modify our module to return the source and dest data as facts. Because these facts will become top-level host variables, we'll want to use more descriptive fact names than source and dest – replace the current module.exit_json line in our module with the code listed:    facts = {'rc_source': module.params['source'],              'rc_dest': module.params['dest']}      module.exit_json(changed=True, ansible_facts=facts) We'll also add a task to our playbook to use one of the facts in a debug statement:  - name: show a fact     debug:       var: rc_dest Now, running the playbook will show the new return data plus the use of the variable:If our module does not return facts (and our previous version of remote_copy.py didn't), we will have to register the output and use set_fact to create the fact for us, as shown in the following code:  - name: do a remote copy     remote_copy:       source: /tmp/rcfoo       dest: /tmp/rcbar     register: mycopy    - name: set facts from mycopy     set_fact:       rc_dest: "{{ mycopy.dest }}" Although it is useful to be able to do this, when designing our own modules, it is better to have the module define the facts required. If this is not done, then the previous register and the set_fact code would need to be repeated for every use of our module in a playbook!


Supporting check mode                                                        To indicate that a module supports check mode, an argument has to be set when creating the module object. This can be done before or after the argument_spec variable is defined in the module object; here, we will do it after it is defined:    module = AnsibleModule(         argument_spec = dict(             source=dict(required=True, type='str'),             dest=dict(required=True, type='str')         ),         supports_check_mode=True     ) If you're modifying your existing code, don't forget to add the comma after the argument_spec dictionary definition, as shown in the preceding code.

Handling check mode                                                        Detecting when check mode is active is very easy. The module object will have a check_mode attribute, which will be set to Boolean value true when check mode is active. In our module, we want to detect whether check mode is active before performing the copy. We can simply move the copy action into an if statement to avoid copying when check mode is active. No further changes to the module are necessary beyond this:    if not module.check_mode:         shutil.copy(module.params['source'],                     module.params['dest']) Now, we can run our playbook and add the -C argument to our execution. This argument engages check mode. We'll also test to ensure that the playbook did not actually create and copy the files. Let's take a look at the following screenshot:Although the module output looks as though it created and copied files, we can see that the files referenced did not exist before execution and still do not exist after execution.






